<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jaap de Dood</title>

    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-" crossorigin="anonymous">

    <link rel="stylesheet" href="/css/layouts/side-menu.css">
    <link rel="stylesheet" href="/css/styles.css">
  </head>
  <body>

    <div id="layout">
      <!-- Menu toggle -->
      <a href="#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
      </a>

      <div id="menu">
        <div class="pure-menu">
          <ul class="pure-menu-list">
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
            <li class="pure-menu-item menu-item-divided"><a href="/Micromouse/" class="pure-menu-link">Micromouse</a></li>
            <li class="pure-menu-item pure-menu-selected"><a href="/Code/" class="pure-menu-link">Code</a></li>
            <li class="pure-menu-item"><a href="/SophEE/" class="pure-menu-link menu-item-divided">SophEE</a></li>
            <li class="pure-menu-item "><a href="/other/" class="pure-menu-link">Other Projects</a></li>
          </ul>
          </ul>
        </div>
      </div>

      <div id="main">
        <div class="header" style="text-align:center;">
          <h1>Code</h1>
          <h2>Examples that I enjoyed working on most</h2>
        </div>
        <div class="content">
          <h1>Flood Fill Pathfinding Algorithm</h1>
          <p>A powerful method of maze solving used for our <a href="/Micromouse/">Micromouse</a> robot.</p>
          <h2>How it works</h2>
          <p>The maze is divided into cells, and the shortest distance from each cell to the goal is calculated. Initially, it is assumed there are no walls in the maze.</p>
          <p>Then, as the mouse tries to reach the goal by moving to the neighboring cell with the lowest distance, the distances are updated every time a wall is discovered. </p>
          <p>This is repeated, and so the mouse is able to map out the maze and the respective distances to the goal of each cell.</p>
          <p>Upon returning to the start, it is simply a matter of connecting the shortest distances to derive a path that leads straight to the goal.</p>
          <div class="pure-g">
            <div class="pure-u-1-4">
              <img class="pure-img-responsive" src="/images/floodfill1.png">
            </div>
            <div class="pure-u-1-4">
              <img class="pure-img-responsive" src="/images/floodfill2.png">
            </div>
            <div class="pure-u-1-4">
              <img class="pure-img-responsive" src="/images/floodfill3.png">
            </div>
            <div class="pure-u-1-4">
              <img class="pure-img-responsive" src="/images/floodfill4.png">
            </div>
          </div>
          <p><a href="http://micromouseusa.com/?page_id=1342">Images from Green Ye's micromouse lecture slides.</a> </p>

          <h2>Pseudocode</h2>
          <p>
            <pre>
create two dimensional array 'distance'
create two dimensional array 'walls'

position = bottom left coordinate of maze

for all elements in walls
    element = empty

for all elements in distance
    element = shortest distance to goal

while position != goal
    if a new wall is discovered
        push current coordinate to stack
        for all accessible neighboring cells
            push neighboring cell coordinates to stack

        while !stack.isEmpty
            coordinate = pop from stack

            if distance != lowest distance of neighbors + 1
                distance = lowest distance of neighbors + 1

                for all accessible neighboring cells
                    push neighboring cell coordinates to stack
    move to neighbor with lowest distance
            </pre>
          </p>
          <p>A stack approach like this is essential, since using recursion will fill up memory much faster on our microcontroller. With a solid understanding of the algorithm and the functions that were going to be needed, it was time to move on to the implementation.</p>

          <h2>C++ Implementation</h2>
          <p>Since the architecture we are using for our mouse is mostly supported by C++ compilers, this was the obvious language to use.</p>
          <p>The full code can be viewed on our project's <a href="https://github.com/ricardoalcaraz/TheJerrys">Github</a> page and is free for use.</p>
          <p>In order to easily test the algorithm and mouse functions, the code includes a DebugTools class. The printMaze function, for example, prints an ASCII maze including distance values and walls.</p>
          <img class="pure-img-responsive" src="/images/printmaze2.png" style="padding-right:10px">
          <p>Besides the outer edge walls, each wall is displayed twice. This is intended, since walls are also stored in memory twice (one from each neighboring cell).</p>
          <p>A function like this is essential for debugging and will also be used during live testing of the mouse, as it has capabilities for bluetooth serial communication.</p>

          <h1>3DoT Bootloader</h1>
          <p>Throughout this summer, I cooperated with Professor Gary Hill on a development board that he uses for his classes at CSULB, the "3DoT" board. The board uses the ATMega32u4 microcontroller which is great for its very small footprint thanking to the "self-programming flash program memory".</p>
          <p>The issue most development boards that use this chip have, however, is that it has to be put into bootloader mode by tapping a reset button - giving you 1-2 seconds to upload your code. Some development boards have tried to improve this by giving you the ability to double-tap the button - giving you 8 seconds to upload your code to the board. Nonetheless, this is still a pain to use. Especially when using the Arduino IDE, which takes a few seconds compiling your code every time you try to upload it. It usually takes 2-3 tries until the code successfully uploads, so we wanted a better solution.</p>
          <p>The solution Professor Hill came up with is a DP3T switch, to set the board to OFF, ON or BOOT. This allows you to simply switch the board to BOOT and take as much time as you need to upload your code. To achieve this, I modified the <a href="https://github.com/adafruit/Caterina-Bootloader">"Caterina" bootloader</a> by Adafruit to work with the 3-position switch. The full code can be viewed <a href="https://github.com/Jaapdedood/3DoTBootloader"> here</a>.</p>
          <p>One of the major breakthroughs I had while developing this code came from a custom bootloader developed by <a href="https://github.com/NicoHood">Nico Hood</a>. I discovered I could easily reset the MCU by enabling the watchdog (configured to system reset mode by default) and calling an endless while(1) loop. With this in mind, (oversimplifying a little) I can simply continuosly reset the mcu while the switch is in "BOOT" mode, waiting for code to be uploaded. If the switch is set to "ON", one of the pins on the board changes to a LOW and the bootloader will jump to the first address of the program uploaded to the board. In the process, I was also able to reduce the size of the bootloader by a few hundred bytes.</p>
          <img class="pure-img-responsive" src="/images/bootloader.png" style="padding-right:10px">
          <p><i>The bootloader conveniently integrated into the Arduino IDE.</i></p>

          <p>See also: <a href="https://www.arxterra.com/troubleshooting-bootloader-burning/">This guide I wrote</a> on burning fuses and uploading bootloaders to ATMega32u4-based boards.</p>
            <script src="/js/ui.js"></script>
  </body>
</html>
